# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Гамов Павел Антонович
### Группа: М80-207Б-18

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


## Введение

Данные хранятся в виде фактов, так называемых предикатов. Обычно для удобства их выносят в отдельный файл.
Чаще всего работа в prolog сводится к обработке фактов, нахождению ситуаций, при которых те или иные условия становятся верными. Таким образом императивный подход к програмированию применим тут частично, чаще приходится думать, при каких условиях данное выражение будет верным, нежели пытаться в лоб найти все такие ситуации. Можно написать условия при которых утверждение будет верным, а дальше интерпритатор сделает всю работу за вас.

## Задание 1.1: Предикат обработки списка

`delN_l(N, S, L) ` - Удаляет первые N элементов списка S, результат выводит в L.

Примеры использования:
```prolog
?- delN_l(2,[1,2,3],X).
X=[3].
?- delN_l(3,[1,2,3,4,5],X).
X=[4,5].
```

Реализация:
```prolog
delN_l(_, [], []).
delN_l(0, L, L) :- !.
delN_l(X, [_H|T], L) :-
    X > 0,
    X1 is X - 1,
    delN_l(X1, T, L).
```

Каждую итерацию декремирует Х, до тех пор пока Х не станет равен 0, тогда вернет полученный L, или же кончится сам список, тогда возвратится [].

## Задание 1.2: Предикат обработки числового списка

`lec_l(L1, L2, RES)` - Лексикографическое сравнение двух числовых списков. Принимает L1, L2, возвращает больший их них.

Примеры использования:
```prolog
?- lec_l([1,2,4],[1,2,3],X).
X=[1,2,4].
?- lec_l([1],[2],X).
X=[2].
```

Реализация:
```prolog
lec_l([],[],[]) :- !.
lec_l([],L,L) :- !.
lec_l(L,[],L) :- !.
lec_l([H1|T1], [H1|T2], RES) :-
    append_l([H1], R, RES),
    lec_l(T1, T2, R).
lec_l([H1|T1], [H2|_T2], RES) :-
    H1 > H2,
    append_l([H1], T1, RES).
lec_l([H1|_T1], [H2|T2], RES) :-
    H1 < H2,
    append_l([H2], T2, RES).
```

Мы смотрим на головы, если они равны, идем внутрь, проверяем хвосты, пока не найдем отличия. Когда головы различаются смотрим какая голова больше, возращаем соответствующий список. Если какой то из списков заканчивается, значит оставшийся больше, возвращаем его. Если закончились оба, они равны, не имеет разницы что возвращать. Идем обратно по рекурсии и соединяем отрезанные головы с возвращенными хвостами в правильном порядке.

## Задание 2: Реляционное представление данных

#### Плюсы
 - Читабельность фактов. Чаще всего предикаты именуются по принципу отношения объектов, допустим, grade дает понять что речь идет о оценке студента по предмету, сразу можно понять, что находится внутри.
 - Манипулирование данными на уровне выходной БД и возможность изменения.
#### Минусы
 - Предикаты, которые я реализовал могут работать корректно только на данной реализации предикатов. Любое несоответсвие может привести к неправильной обработке данных или ошибке типизации.
 - Самый медленный доступ к данным.


`h1()` - печатает пару "предмет" - "средняя оценка по нему". Использует встроенный предикат findall для поиска всех предметов.

`h1_1(A)` - A - список предметов. Внутри рекурсивно печатает для каждого средний балл. Внутри использет предикат subject для перевода из аббревиатуры в полное название предмета.

`h1_2(H, GRADE)` - Н - предмет, GRADE - соответствующая ему средняя оценка. Использует встроенный предикат findall для поиска всех оценок по заданному предмету для дальшейшей работы с ними.

`h2()` - печатает пару "группа" - "кол-во несдавших учеников". Использует встроенный предикат findall дважды для поиска всех групп и всех учеников.

`h2_1(GROUP1, GROUP2)` - Может оказаться, что кто то из учеников попадет в список дважды или более раз, поэтому необходимо удалить повторения этим предикатом. Возвращает список учеников без повторений.

`h2_2(GROUP, STUDENTS)` - Получает список групп и студентов и пишет тех, кто не сдал. Для каждой группы проверяется полный список учеников.

`h2_3(GROUP, STUD, INGROUP)` - Необходимо отсеить тех учеников, которые не находятся в данной группе, возвращает список учеников из полного списка STUD, которые учатся в группе GROUP.

`h2_4(GROUP, INGROUP, COUNT)` - Возвращает кол-во учеников которые не сдали какой то предмет их списка INGROUP, которые учатся в группе GROUP.

`h2_5(G, H, [H])` - Требуется для проверки принадлежности ученика H к группе G, возвращает ученика в формате еденичного списка, иначе пустой список. Внутри использует предикат student для проверки принадлежности к группе.

`h2_6(H, U)` - Нужен для рекурсивного подстчета кол-ва студентов, не сдавших экзамен, принимает студента H, возврщает 1 если не сдал, 0 если сдал. Использует внутри предикат grade.

`h3()` - Возвращает пару "предмет" - "кол-во несдавших этот предмет студентов". Использует дважды предикат findall для нахождения всех предметов и всех учеников.

`h3_1(SUB, STUDENTS)` - Рекурсивно проходит по всем предметам печатая кол-во несдавших.  Внутри использет предикат subject для перевода из аббревиатуры в полное название предмета.

`h3_2(SUB, STUD, RES)` - Считает рекурсивно для предмета SUB по всем ученикам из STUD кол-во несдавших, возвращает RES.

`h3_3(STUD, SUB, X)` - Предикат проверки на плохую оценку, если оценка 2, возвращает в X 1, иначе 0. Использует предикат grade.

## Выводы

 - Ключевой момент в написании обработчиков баз данных - умение работы с отладчиком, режим trace в swipl, где я работаю, дает такие возможности, ведь пока еще не до конца понятно, что и как работает, умение писать сразу качественный код приходит со временем, а учится как-то надо.

 - Язык требовательный, если забыть какой то особый случай и не прописать его, програма ляжет и даже непонятно где, часто приходится сидеть с листом бумаги и ручкой, рисовать рекурсии и включения, можно легко написать неэффективный код, но цель - ужать до минимального кол-ва функций, очень тяжело перестроиться с других языков программирования, таких как С, но очень помогает отладчик.
