\section{Описание}

Идея реализации - создание главного файла main.c, где мы будем считывать строки (команды) и числа и отправлять их через анализатор в структуру, допустим мы читаем +, следовательно дальше мы читаем строку в буфер и число, которые будут добавлены в дерево. Отдельно поговорим про саму структуру дерева, я разбил ее на темаические файлы, в которых реализован функционал структуры. 

Файл clear.c содержит в себе функции удаления памяти в структуре, очистки нодов и рекурсивные очистки и удаления поддеревьев. 

delete.c содежит в себе функции удаления элементов из дерева, включая в себя как легкие - удаление из листа, так и удаление из не листьев, требующих перестройки и перекомпановки дерева, посредством слияний и перебросок из левых или правых деревьев.

insert.c содержит функционал по добавлению элементов в структуру, добавление в лист, сильное добавление требуется для добавления в нод элемента с фиксированными хвостами и ссылками на потомков (требуется в некоторых случаях при переброске элементов при слиянии нодов), функция разделения дерева на элемент и два его потомка (требуется после вставки для устранения переполнения при добавлении элемента, таким образом если добавив элемент окажется, что нод переполнен, вызывается функция деления нода).

m.c - общий файл который нужен для описания более общих функций которые нужны для преобразования входных данных, функции сравнения строк между собой, функции бинарного поиска, который требуется для более быстрого нахождения строк в нодах, при больших T это играет большую роль, так как операция сравнения занимает слишком много времени. Также главная функция обьявления и выделения памяти под структуру, а также функция проверки принадлежности элемента к дереву.

merge.c - содержит в себе лишь одну функцию по слиянию двух нодов в один, содержит под собой 6 случаев, включая нулевые.

saveload.c - функционал для осуществления бинарной серриализации и бинарной десерриализации структуры из/в файл. Для сохранения дерева в файл и дальнейшей 

\pagebreak

\section{Консоль}
\begin{alltt}
root@pavel:/media/sf_Coding/3_sem/Da/2lab/src# make
gcc    -c -o code/main.o code/main.c
gcc    -c -o code/m.o code/m.c
gcc    -c -o code/delete.o code/delete.c
gcc    -c -o code/insert.o code/insert.c
gcc    -c -o code/clear.o code/clear.c
gcc    -c -o code/saveload.o code/saveload.c
gcc    -c -o code/merge.o code/merge.c
gcc -Wall -pedantic -std=c99 -g code/*.o -o main

root@pavel:/media/sf_Coding/3_sem/Da/2lab/src# make gen
python generator.py
how many iterations?	10000

root@pavel:/media/sf_Coding/3_sem/Da/2lab/src# make valgrind
valgrind -s --leak-check=full ./main < text.txt > res.txt
==3637== Memcheck, a memory error detector
==3637== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==3637== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==3637== Command: ./main
==3637==
==3637==
==3637== HEAP SUMMARY:
==3637==     in use at exit: 0 bytes in 0 blocks
==3637==   total heap usage: 387,870 allocs, 387,870 frees, 63,376,749 bytes allocated
==3637==
==3637== All heap blocks were freed -- no leaks are possible
==3637==
==3637== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\end{alltt}

\pagebreak