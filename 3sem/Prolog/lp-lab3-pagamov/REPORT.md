#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

<!-- > *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)* -->


## Введение

<!-- Какие задачи удобным образом решаются методом поиска в пространстве состояний?
Почему Prolog оказывается удобным языком для решения таких задач? -->

Практически все задачи имеющие интерпритацию в пространстве состояний могут быть решены методом поиска в пространстве состояний. Это следует из определения, что агент действия у нас по дефолту внутреннеe текущее состояние машины, также присутствует цель и правила перехода. Все упирается в умение правильно создать ситуацию и задать правила перехода для агента.

## Задание

5. Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром.

## Принцип решения

<!-- Опишите своими словами принцип решения задачи, приведите важные фрагменты кода. Какие алгоритмы поиска вы использовали? -->

Если писать конкретные правила перехода из состояния в состояние, важно иметь понятие о том, в каком состояни мы уже были, так как если вы окажемся в нем повторно, алгоритм зациклится и все будет плохо. Для решения данной задачи я использовал идею истории совместно с поиском в глубину. Я имел в наличии список всех предыдущих состояний, и если агент делал шаг, я проверял, не оказался ли он в предыдущем состоянии. Если агент попал в ситуацию, когда любое его действие приводит к циклу, происходит откат еще дальше.

```prolog
solve(A,B):-
    search(B,[A]).
```

Главная функция, фактически мы идем нет от А к Б, а обратно, так как потом будет проще "развернуть" список состояний по которым мы шли.

```prolog
search(B,[B|Tail]):-
    !,
    answer([B|Tail]).
```

Если конечное состояние совпало с результатом работы алгоритма, значит в списке списков находится путь от А к Б. Предикат answer "разворачивает" списко и выводит каждый.

```prolog
search(B,[A|Tail]):-
    makeMove(A,C),
    not(inHistory(C,Tail)),
    search(B,[C,A|Tail]).
```

Если мы все еще не пришли к ответу, создаем из А, с помощью предиката makeMove, C, далее, если он оказывается в истории, откатываемся назад, если же все хорошо, заносим его в историю и продолжаем поиск в глубину.

## Результаты

В результате, дойти из состояния А в состояние Б можно за 16 шагов.
Так как это поиск в глубину, наличие решения зависит только от возможности попадания в финальное состояние, допустим, если в начальном состоянии находится N элементов а в конечном N+1, то конечно попасть сюда мы не можем, в любом другом случае, рано или поздно мы придем к результату.

Для данной задачи, где мы имеем длинну списка N, число белых W, число черных B, а также одно пустое место, такие что B+W+1 == N, колличество перестановок равно, если не изменяет память и я помню формулы комбинаторики, N!/(W!B!1!), тоесть часто большое, но конечное число.

Использование истории позволяет не думать о зацикливании, таким образом имея конечное время и конечную память, возможно найти все пути, или хотя бы один, из А в Б.

## Выводы

<!-- Сформулируйте *содержательные* выводы по лабораторной работе.
Чему она вас научила? Над чем заставила задуматься? -->

<!-- Какие алгоритмы поиска в каких случаях удобно использовать? Какие оказались оптимальными в вашем конкретном случае? -->

Методы поиска в пространстве состояний делятся на информированные и неинформированные.

Неинформированные методы (методы слепого поиска, методы грубой силы) не используют никакой информации о конкретной задаче, кроме информации о том, как отличить целевое состояние от любого другого.

Алгоритмы этой группы последовательно порождают все возможные состояния, достижимые из исходного состояния до тех пор, пока не будет найдено целевое состояние (решение). Различия между методами неинформированного поиска сводятся к последовательности просмотра состояний. Для нашей задачи это может сработать при длинне доски до 4, иначе стак переполняется и программа ломается.

Информированные методы поиска (эвристические методы) пользуются дополнительной информацией о конкретной задаче. Дополнительная информация (эвристика) позволяет сократить перебор путём исключения заведомо бесперспективных вариантов. Такой подход ускоряет работу алгоритма по сравнению с полным перебором. Недостатком эвристических алгоритмов может быть отсутствие гарантии того, что выбрано правильное или наилучшее из всех возможных решение. Этот метод обеспечивается наличием истории состояний, так как агент на основании состояния однозначно переходит в иное, мы можем использовать такой алгоритм для более быстрого поиска, за счет использования большего кол-ва памяти на состояния.

Модель пространства состояний позволяет свести логические задачи к достаточно простой модели, при которой агент может передвигаться по пространству состояний на основании доступных шагов. Выбор между поиском в ширину и грубину позволяет настраивать и подгонять решение под конкретную задачу.

Очень помогает система отката в языке Prolog, если решение зашло в тупик существует возможность сделать откат в решении и пойти по другому маршруту, прямо к решению.

Также значительным плюсом помимо отката, в языке Prolog отсутствует типизация данных, есть встроенные операторы сравнения и отрицания, решая подобную задачу допустим на С мы бы столкнулись с многими проблемами реализации библеотек, следовательно, реализация решения поиска по состояниям на языке Prolog значительно быстрее чем на других языках, включая императивные языкиы. 

<!-- Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную. -->
