\section{Эллиптические кривые}

Эллиптическая кривая — это просто множество точек, описываемое уравнением:

$$
y^2 = x^3 + ax + b
$$
$$
4a^3 + 27b^2 \neq 0
$$

В нашем случае учитывая точку на бесконечности, а также учитывая модульную арифметику конечномерного поля получается:

$$
\{(x,y) \in \mathds{R} \, | \,y^2 \equiv x^3 + ax + b \, (mod \, p), 4a^3 + 27b^2 \neq 0\} \cup \{0\}
$$

Для того чтобы найти все точки принадлежащие полю, можно просто пробежаться по всем целым точкам и проверить на принадлежность.

Для этого взял кривую $y^2 = x^3 + 1487x + 227 (mod 70997)$

\begin{lstlisting}
A,B,P = 1487,227,70997
if (4 * A * A * A + 27 * B * B) % P != 0:
    dots = []
    t = time()
    y_get,y,order = 0,0,1
    for x in range(P):
        y_get = c_mod((x**3 + A*x + B), P)
        for y in range(sqr(y_get),P):
            if (y*y) % P == y_get:
                dots.append([x,y])
                order += 1
\end{lstlisting}

Так как такой подход крайне тяжелый, Python справляется с этим крайне тяжело.

\section{Порядок точки}

Будем вычислять порядок первой попавшейся нам на пути точки.

\begin{lstlisting}
min = order
count = 1
for i in points:
    s,p = [i[0],i[1]],[i[0],i[1]]
    print('working with', s)
    while s[1] != 0:
        if s == [p[0],P-p[1]]:
            # print('\t'+str(count))
            s = [0,0]
        elif s == p:
            m = c_mod(c_mod((3*s[0]*s[0])%P+A,P)*rev((2*s[1])%P,P),P)
            x_new = c_mod((m*m)%P-(2*s[0])%P,P)
            s = [x_new, c_mod((m*c_mod(s[0]-x_new,P))%P-s[1],P)]
        else:
            m = c_mod(c_mod(i[1]-s[1], P)*rev(c_mod(i[0]-s[0],P),P),P)
            x_new = c_mod((m*m)%P-s[0]-i[0],P)
            s = [x_new, c_mod((m*c_mod(s[0]-x_new,P))%P-s[1],P)]
        count += 1
    if count < min:
        min = count
        if min == 1:
            break
    count = 1
print('N =', min)
print('total time','{0:.2f}'.format(time()-t), 'min')
ex = input()
\end{lstlisting}

Как видно принцип простой, до тех пор пока точка не нулевая, либо складываем ее саму с собой используя прозводную касательной к кривой, если же точка отлична, тогда используем другой способ нахождения, таким образом находим цепочку точек принадлежащих кривой. Далее выводим порядок точки, время работы, порядок точки и кривой.

\section{Результат}

Для моей кривой результаты таковы:

\begin{lstlisting}
5040490825/5040574009 100.00 % need time: 13.52 min
order 71240
working with [0, 13221]
N = 35620
total time 13.60 min
\end{lstlisting}

\section{Информация о машине}

macOS Catalina 10.15.7

MacBook Pro (13-inch, 2017, Two Thunderbolt 3 ports)

Процессор 2,3 GHz 2‑ядерный процессор Intel Core i5

Память 8 ГБ 2133 MHz LPDDR3

Графика Intel Iris Plus Graphics 640 1536 МБ

\section{Заключение}

В данной лабораторной работе я подобрал эллиптическую кривую над конечным простым полем, порядок точки которой полным перебором находится примерно за 10 минут на ПК. Безусловно, существуют алгоритмы, выполняющие данную задачу в разы быстрее, например, для поиска порядка эллиптической кривой можно использовать алгоритм больших и маленьких шагов, а для поиска порядка точки можно применить алгоритм удвоения-сложения. Однако, не смотря на улучшенные методы решения задачи, я все ровно узнал много нового об аспектах криптографии, использующую для шифрования, в том или ином виде, эллиптические кривые. 







