#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Гамов П.А. М80-207б-18

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

<!-- > *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)* -->


## Введение

<!-- Какие подходы обычно применяются для обработки естественных и искусственных языков?
Почему Prolog оказывается удобным языком для решения таких задач? -->

Обработка естественного языка — общее направление искусственного интеллекта и математической лингвистики. Оно изучает проблемы компьютерного анализа и синтеза естественных языков. Существует множество проблем связанных с обработкой различных языков, возьмем к примеру обработку русского языка: распознование анафор, свободный порядок слов, неологизмы, правильное понимание омонимов - все это не делает задачу проще, до тех пор пока мы примерно знаем границы допустимого. Старые системы по распознаванию языка по типу SHRDLU работали прекрасно пока данные не вышли за пределы рабочего поля и новые слова и предложения не стали ломать систему. Сейчас существует множество методов решения задач обработки языков - векторный метод, когда текст переносится в вектор на N мерном пространстве, где уже проще загнать его в заранее обученную нейронную сеть, а то и несколько, метод машинного перевода, позволяющий перевести из языка А в язык Б, который уже легко распознать на ранее обученных системах.

Использование языка Prolog позволяет, написав грамматику языка, получить рабочий синтаксический анализатор или по крайней мере его основу. Возможность использования вложенных списков позволяет написать классификаторы и лексикографические деревья. Из-за специфики языка, Prolog может стать незаменимиым инструментов при создании парсеров и обработчиков текстов, ведь списки довольно просто обрабатывать, объекты языка пишутся в предикатах, что позовляет разгараничить язык и ввести правила. Конечно, для бесконечного языка такое не подойдет, так как слишком много правил смогут запутать любого. Однако, вводя правила разграничения, анализатор легко маштабировать, просто ввести новый символ или слово в поле класса.

## Задание

4. Реализовать синтаксический анализатор арифметического выражения для перевода его в префиксную форму. В выражении допустимы операции + , - , * , / .

## Принцип решения

<!-- Опишите своими словами принцип решения задачи, приведите важные фрагменты кода. -->

Для парсинга из инфиксной в Польскую(префиксную) сначала необходимо ввести правила. Алфавит операторов будет состоять из сложения, вычитания, деления и умножения, также будут левая и правая скобки, а также сами числа.

```prolog
isNumber(X):-
    number(X).
low_operator('+').
low_operator('-').
hi_operator('/').
hi_operator('*').
l_scob('(').
r_scob(')').
```

Разграничим алфавит, это поможет нам в будущем, важный момент, low и hi операторы различны потому что у низ различный преоритет операции.

```prolog
reverse(List1, List2):-
    reverseUnder(List1, [], List2).
```

Для парса напишем переворот списка, так как из обычного алгоритм нам ничего не позволит сделать.

```prolog
addLast([], X, [X]).
addLast([Head1|Tail1], X, [Head1|Tail2]):-
    addLast(Tail1, X, Tail2).
```

Предикат добавления в конец списка, для того чтобы получать результирующий стек.

```prolog
calculate(Get, Res):-
    reverse(Get, Piv1),
    prefix(Piv1, [], [], Piv),
    reverse(Piv, Res), !.
```

Основная функция, сначала переворачиваем, считаем как обычную Дейкстру, переворачиваем обратно.

## Результаты

<!-- Приведите результаты работы программы. -->

```prolog
?- calculate([2,'+',3,'/',1,'*',4],X).
X = [+, 2, /, 3, *, 1, 4].
```

```prolog
?- calculate([1,'/',19,'/','(',1,'-',4,')','*',8],X).
X = [/, 1, /, 19, *, -, 1, 4, 8].
```

Программа прекрасно разбирается с преоритетом операций при переводе из инфиксной в префиксную форму.

## Выводы

<!-- Сформулируйте *содержательные* выводы по лабораторной работе.
Чему она вас научила? Над чем заставила задуматься? -->

Понимание моделей и основных принципов обработки естественных языков - узкоспециализированная ветвь программирования. Тем не менее она очень важна в текущих реалиях, так как современные машины обладают всеми необходимыми инструментами для воплощения в жизнь давней идеи человека - использование машин не только для подсчета чисел, но также как собеседника, копии человека, помощника, того, кто действительно похож на нас, людей. Современные голосовые помощники, боты, поисковики контекстной рекламы, все они используют эти алгоритмы, что делает жизнь человека несколько проще, ведь можно не только сесть и запрограммировать на машине, то, что тебе нужно, но можно просто взять, и попросить, машина сама тебя поймет.

<!-- Удобным ли оказывается Пролог для решения задач грамматического разбора? Почему? -->

Как я писал выше, Prolog позволяет в достаточно простой форме записать характеристики языка, над которым мы работаем, чтобы получить новые данные: разбить язык на более простые составляющие, что в дальнейшем обеспечит более простую работу другим программам, основанным на других, более мощных алгоритмах. Алгоритмы разбиения на предложения, слова, токенизацию текста - все это можно довольно легко реализовать на Prolog, ввиду устройства языка.

<!-- Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную. -->
